// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CANVAS_FB_H_
#define FLATBUFFERS_GENERATED_CANVAS_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace fb {

struct Color;
struct ColorBuilder;

struct Image;
struct ImageBuilder;

struct FontFace;
struct FontFaceBuilder;

struct CanvasOperation;
struct CanvasOperationBuilder;

struct AddArc;
struct AddArcBuilder;

struct AddCircle;
struct AddCircleBuilder;

struct AddLineTo;
struct AddLineToBuilder;

struct AddRectangle;
struct AddRectangleBuilder;

struct Clear;
struct ClearBuilder;

struct ClipRectangle;
struct ClipRectangleBuilder;

struct DrawImage;
struct DrawImageBuilder;

struct DrawPixel;
struct DrawPixelBuilder;

struct DrawString;
struct DrawStringBuilder;

struct DrawStringWrapped;
struct DrawStringWrappedBuilder;

struct FillPath;
struct FillPathBuilder;

struct FontHeight;
struct FontHeightBuilder;

struct MeasureString;
struct MeasureStringBuilder;

struct Pop;
struct PopBuilder;

struct Push;
struct PushBuilder;

struct Rotate;
struct RotateBuilder;

struct Scale;
struct ScaleBuilder;

struct SetColor;
struct SetColorBuilder;

struct SetFontFace;
struct SetFontFaceBuilder;

struct TransformPoint;
struct TransformPointBuilder;

struct Translate;
struct TranslateBuilder;

struct CanvasOperationList;
struct CanvasOperationListBuilder;

enum Align : int32_t {
  Align_LEFT = 0,
  Align_CENTER = 1,
  Align_RIGHT = 2,
  Align_MIN = Align_LEFT,
  Align_MAX = Align_RIGHT
};

inline const Align (&EnumValuesAlign())[3] {
  static const Align values[] = {
    Align_LEFT,
    Align_CENTER,
    Align_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesAlign() {
  static const char * const names[4] = {
    "LEFT",
    "CENTER",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlign(Align e) {
  if (::flatbuffers::IsOutRange(e, Align_LEFT, Align_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlign()[index];
}

struct Color FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_R = 4,
    VT_G = 6,
    VT_B = 8,
    VT_ALPHA = 10
  };
  uint32_t r() const {
    return GetField<uint32_t>(VT_R, 0);
  }
  uint32_t g() const {
    return GetField<uint32_t>(VT_G, 0);
  }
  uint32_t b() const {
    return GetField<uint32_t>(VT_B, 0);
  }
  uint32_t alpha() const {
    return GetField<uint32_t>(VT_ALPHA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_R, 4) &&
           VerifyField<uint32_t>(verifier, VT_G, 4) &&
           VerifyField<uint32_t>(verifier, VT_B, 4) &&
           VerifyField<uint32_t>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct ColorBuilder {
  typedef Color Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_r(uint32_t r) {
    fbb_.AddElement<uint32_t>(Color::VT_R, r, 0);
  }
  void add_g(uint32_t g) {
    fbb_.AddElement<uint32_t>(Color::VT_G, g, 0);
  }
  void add_b(uint32_t b) {
    fbb_.AddElement<uint32_t>(Color::VT_B, b, 0);
  }
  void add_alpha(uint32_t alpha) {
    fbb_.AddElement<uint32_t>(Color::VT_ALPHA, alpha, 0);
  }
  explicit ColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Color> CreateColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t r = 0,
    uint32_t g = 0,
    uint32_t b = 0,
    uint32_t alpha = 0) {
  ColorBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  return builder_.Finish();
}

struct Image FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMAGE_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *image_data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_IMAGE_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IMAGE_DATA) &&
           verifier.VerifyVector(image_data()) &&
           verifier.EndTable();
  }
};

struct ImageBuilder {
  typedef Image Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_image_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data) {
    fbb_.AddOffset(Image::VT_IMAGE_DATA, image_data);
  }
  explicit ImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Image>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Image> CreateImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> image_data = 0) {
  ImageBuilder builder_(_fbb);
  builder_.add_image_data(image_data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Image> CreateImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *image_data = nullptr) {
  auto image_data__ = image_data ? _fbb.CreateVector<uint8_t>(*image_data) : 0;
  return fb::CreateImage(
      _fbb,
      image_data__);
}

struct FontFace FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FontFaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct FontFaceBuilder {
  typedef FontFace Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FontFace::VT_NAME, name);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(FontFace::VT_SIZE, size, 0);
  }
  explicit FontFaceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FontFace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FontFace>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FontFace> CreateFontFace(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t size = 0) {
  FontFaceBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FontFace> CreateFontFaceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t size = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::CreateFontFace(
      _fbb,
      name__,
      size);
}

struct CanvasOperation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CanvasOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADD_ARC = 4,
    VT_ADD_CIRCLE = 6,
    VT_ADD_LINE_TO = 8,
    VT_ADD_RECTANGLE = 10,
    VT_CLEAR = 12,
    VT_CLIP_RECTANGLE = 14,
    VT_DRAW_IMAGE = 16,
    VT_DRAW_PIXEL = 18,
    VT_DRAW_STRING = 20,
    VT_DRAW_STRING_WRAPPED = 22,
    VT_FILL_PATH = 24,
    VT_POP = 26,
    VT_PUSH = 28,
    VT_ROTATE = 30,
    VT_SCALE = 32,
    VT_SET_COLOR = 34,
    VT_SET_FONT_FACE = 36,
    VT_TRANSLATE = 38
  };
  const fb::AddArc *add_arc() const {
    return GetPointer<const fb::AddArc *>(VT_ADD_ARC);
  }
  const fb::AddCircle *add_circle() const {
    return GetPointer<const fb::AddCircle *>(VT_ADD_CIRCLE);
  }
  const fb::AddLineTo *add_line_to() const {
    return GetPointer<const fb::AddLineTo *>(VT_ADD_LINE_TO);
  }
  const fb::AddRectangle *add_rectangle() const {
    return GetPointer<const fb::AddRectangle *>(VT_ADD_RECTANGLE);
  }
  const fb::Clear *clear() const {
    return GetPointer<const fb::Clear *>(VT_CLEAR);
  }
  const fb::ClipRectangle *clip_rectangle() const {
    return GetPointer<const fb::ClipRectangle *>(VT_CLIP_RECTANGLE);
  }
  const fb::DrawImage *draw_image() const {
    return GetPointer<const fb::DrawImage *>(VT_DRAW_IMAGE);
  }
  const fb::DrawPixel *draw_pixel() const {
    return GetPointer<const fb::DrawPixel *>(VT_DRAW_PIXEL);
  }
  const fb::DrawString *draw_string() const {
    return GetPointer<const fb::DrawString *>(VT_DRAW_STRING);
  }
  const fb::DrawStringWrapped *draw_string_wrapped() const {
    return GetPointer<const fb::DrawStringWrapped *>(VT_DRAW_STRING_WRAPPED);
  }
  const fb::FillPath *fill_path() const {
    return GetPointer<const fb::FillPath *>(VT_FILL_PATH);
  }
  const fb::Pop *pop() const {
    return GetPointer<const fb::Pop *>(VT_POP);
  }
  const fb::Push *push() const {
    return GetPointer<const fb::Push *>(VT_PUSH);
  }
  const fb::Rotate *rotate() const {
    return GetPointer<const fb::Rotate *>(VT_ROTATE);
  }
  const fb::Scale *scale() const {
    return GetPointer<const fb::Scale *>(VT_SCALE);
  }
  const fb::SetColor *set_color() const {
    return GetPointer<const fb::SetColor *>(VT_SET_COLOR);
  }
  const fb::SetFontFace *set_font_face() const {
    return GetPointer<const fb::SetFontFace *>(VT_SET_FONT_FACE);
  }
  const fb::Translate *translate() const {
    return GetPointer<const fb::Translate *>(VT_TRANSLATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADD_ARC) &&
           verifier.VerifyTable(add_arc()) &&
           VerifyOffset(verifier, VT_ADD_CIRCLE) &&
           verifier.VerifyTable(add_circle()) &&
           VerifyOffset(verifier, VT_ADD_LINE_TO) &&
           verifier.VerifyTable(add_line_to()) &&
           VerifyOffset(verifier, VT_ADD_RECTANGLE) &&
           verifier.VerifyTable(add_rectangle()) &&
           VerifyOffset(verifier, VT_CLEAR) &&
           verifier.VerifyTable(clear()) &&
           VerifyOffset(verifier, VT_CLIP_RECTANGLE) &&
           verifier.VerifyTable(clip_rectangle()) &&
           VerifyOffset(verifier, VT_DRAW_IMAGE) &&
           verifier.VerifyTable(draw_image()) &&
           VerifyOffset(verifier, VT_DRAW_PIXEL) &&
           verifier.VerifyTable(draw_pixel()) &&
           VerifyOffset(verifier, VT_DRAW_STRING) &&
           verifier.VerifyTable(draw_string()) &&
           VerifyOffset(verifier, VT_DRAW_STRING_WRAPPED) &&
           verifier.VerifyTable(draw_string_wrapped()) &&
           VerifyOffset(verifier, VT_FILL_PATH) &&
           verifier.VerifyTable(fill_path()) &&
           VerifyOffset(verifier, VT_POP) &&
           verifier.VerifyTable(pop()) &&
           VerifyOffset(verifier, VT_PUSH) &&
           verifier.VerifyTable(push()) &&
           VerifyOffset(verifier, VT_ROTATE) &&
           verifier.VerifyTable(rotate()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyTable(scale()) &&
           VerifyOffset(verifier, VT_SET_COLOR) &&
           verifier.VerifyTable(set_color()) &&
           VerifyOffset(verifier, VT_SET_FONT_FACE) &&
           verifier.VerifyTable(set_font_face()) &&
           VerifyOffset(verifier, VT_TRANSLATE) &&
           verifier.VerifyTable(translate()) &&
           verifier.EndTable();
  }
};

struct CanvasOperationBuilder {
  typedef CanvasOperation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_add_arc(::flatbuffers::Offset<fb::AddArc> add_arc) {
    fbb_.AddOffset(CanvasOperation::VT_ADD_ARC, add_arc);
  }
  void add_add_circle(::flatbuffers::Offset<fb::AddCircle> add_circle) {
    fbb_.AddOffset(CanvasOperation::VT_ADD_CIRCLE, add_circle);
  }
  void add_add_line_to(::flatbuffers::Offset<fb::AddLineTo> add_line_to) {
    fbb_.AddOffset(CanvasOperation::VT_ADD_LINE_TO, add_line_to);
  }
  void add_add_rectangle(::flatbuffers::Offset<fb::AddRectangle> add_rectangle) {
    fbb_.AddOffset(CanvasOperation::VT_ADD_RECTANGLE, add_rectangle);
  }
  void add_clear(::flatbuffers::Offset<fb::Clear> clear) {
    fbb_.AddOffset(CanvasOperation::VT_CLEAR, clear);
  }
  void add_clip_rectangle(::flatbuffers::Offset<fb::ClipRectangle> clip_rectangle) {
    fbb_.AddOffset(CanvasOperation::VT_CLIP_RECTANGLE, clip_rectangle);
  }
  void add_draw_image(::flatbuffers::Offset<fb::DrawImage> draw_image) {
    fbb_.AddOffset(CanvasOperation::VT_DRAW_IMAGE, draw_image);
  }
  void add_draw_pixel(::flatbuffers::Offset<fb::DrawPixel> draw_pixel) {
    fbb_.AddOffset(CanvasOperation::VT_DRAW_PIXEL, draw_pixel);
  }
  void add_draw_string(::flatbuffers::Offset<fb::DrawString> draw_string) {
    fbb_.AddOffset(CanvasOperation::VT_DRAW_STRING, draw_string);
  }
  void add_draw_string_wrapped(::flatbuffers::Offset<fb::DrawStringWrapped> draw_string_wrapped) {
    fbb_.AddOffset(CanvasOperation::VT_DRAW_STRING_WRAPPED, draw_string_wrapped);
  }
  void add_fill_path(::flatbuffers::Offset<fb::FillPath> fill_path) {
    fbb_.AddOffset(CanvasOperation::VT_FILL_PATH, fill_path);
  }
  void add_pop(::flatbuffers::Offset<fb::Pop> pop) {
    fbb_.AddOffset(CanvasOperation::VT_POP, pop);
  }
  void add_push(::flatbuffers::Offset<fb::Push> push) {
    fbb_.AddOffset(CanvasOperation::VT_PUSH, push);
  }
  void add_rotate(::flatbuffers::Offset<fb::Rotate> rotate) {
    fbb_.AddOffset(CanvasOperation::VT_ROTATE, rotate);
  }
  void add_scale(::flatbuffers::Offset<fb::Scale> scale) {
    fbb_.AddOffset(CanvasOperation::VT_SCALE, scale);
  }
  void add_set_color(::flatbuffers::Offset<fb::SetColor> set_color) {
    fbb_.AddOffset(CanvasOperation::VT_SET_COLOR, set_color);
  }
  void add_set_font_face(::flatbuffers::Offset<fb::SetFontFace> set_font_face) {
    fbb_.AddOffset(CanvasOperation::VT_SET_FONT_FACE, set_font_face);
  }
  void add_translate(::flatbuffers::Offset<fb::Translate> translate) {
    fbb_.AddOffset(CanvasOperation::VT_TRANSLATE, translate);
  }
  explicit CanvasOperationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CanvasOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CanvasOperation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CanvasOperation> CreateCanvasOperation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::AddArc> add_arc = 0,
    ::flatbuffers::Offset<fb::AddCircle> add_circle = 0,
    ::flatbuffers::Offset<fb::AddLineTo> add_line_to = 0,
    ::flatbuffers::Offset<fb::AddRectangle> add_rectangle = 0,
    ::flatbuffers::Offset<fb::Clear> clear = 0,
    ::flatbuffers::Offset<fb::ClipRectangle> clip_rectangle = 0,
    ::flatbuffers::Offset<fb::DrawImage> draw_image = 0,
    ::flatbuffers::Offset<fb::DrawPixel> draw_pixel = 0,
    ::flatbuffers::Offset<fb::DrawString> draw_string = 0,
    ::flatbuffers::Offset<fb::DrawStringWrapped> draw_string_wrapped = 0,
    ::flatbuffers::Offset<fb::FillPath> fill_path = 0,
    ::flatbuffers::Offset<fb::Pop> pop = 0,
    ::flatbuffers::Offset<fb::Push> push = 0,
    ::flatbuffers::Offset<fb::Rotate> rotate = 0,
    ::flatbuffers::Offset<fb::Scale> scale = 0,
    ::flatbuffers::Offset<fb::SetColor> set_color = 0,
    ::flatbuffers::Offset<fb::SetFontFace> set_font_face = 0,
    ::flatbuffers::Offset<fb::Translate> translate = 0) {
  CanvasOperationBuilder builder_(_fbb);
  builder_.add_translate(translate);
  builder_.add_set_font_face(set_font_face);
  builder_.add_set_color(set_color);
  builder_.add_scale(scale);
  builder_.add_rotate(rotate);
  builder_.add_push(push);
  builder_.add_pop(pop);
  builder_.add_fill_path(fill_path);
  builder_.add_draw_string_wrapped(draw_string_wrapped);
  builder_.add_draw_string(draw_string);
  builder_.add_draw_pixel(draw_pixel);
  builder_.add_draw_image(draw_image);
  builder_.add_clip_rectangle(clip_rectangle);
  builder_.add_clear(clear);
  builder_.add_add_rectangle(add_rectangle);
  builder_.add_add_line_to(add_line_to);
  builder_.add_add_circle(add_circle);
  builder_.add_add_arc(add_arc);
  return builder_.Finish();
}

struct AddArc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddArcBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  double start_angle() const {
    return GetField<double>(VT_START_ANGLE, 0.0);
  }
  double end_angle() const {
    return GetField<double>(VT_END_ANGLE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           VerifyField<double>(verifier, VT_START_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_END_ANGLE, 8) &&
           verifier.EndTable();
  }
};

struct AddArcBuilder {
  typedef AddArc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddArc::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddArc::VT_Y, y, 0.0);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(AddArc::VT_RADIUS, radius, 0.0);
  }
  void add_start_angle(double start_angle) {
    fbb_.AddElement<double>(AddArc::VT_START_ANGLE, start_angle, 0.0);
  }
  void add_end_angle(double end_angle) {
    fbb_.AddElement<double>(AddArc::VT_END_ANGLE, end_angle, 0.0);
  }
  explicit AddArcBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddArc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddArc>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddArc> CreateAddArc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double radius = 0.0,
    double start_angle = 0.0,
    double end_angle = 0.0) {
  AddArcBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct AddCircle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddCircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_RADIUS = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           verifier.EndTable();
  }
};

struct AddCircleBuilder {
  typedef AddCircle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddCircle::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddCircle::VT_Y, y, 0.0);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(AddCircle::VT_RADIUS, radius, 0.0);
  }
  explicit AddCircleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddCircle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddCircle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddCircle> CreateAddCircle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double radius = 0.0) {
  AddCircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct AddLineTo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddLineToBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct AddLineToBuilder {
  typedef AddLineTo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddLineTo::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddLineTo::VT_Y, y, 0.0);
  }
  explicit AddLineToBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddLineTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddLineTo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddLineTo> CreateAddLineTo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  AddLineToBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct AddRectangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddRectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           verifier.EndTable();
  }
};

struct AddRectangleBuilder {
  typedef AddRectangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddRectangle::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddRectangle::VT_Y, y, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(AddRectangle::VT_WIDTH, width, 0.0);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(AddRectangle::VT_HEIGHT, height, 0.0);
  }
  explicit AddRectangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddRectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddRectangle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddRectangle> CreateAddRectangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double width = 0.0,
    double height = 0.0) {
  AddRectangleBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Clear FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClearBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ClearBuilder {
  typedef Clear Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ClearBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Clear> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Clear>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Clear> CreateClear(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ClearBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ClipRectangle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClipRectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           verifier.EndTable();
  }
};

struct ClipRectangleBuilder {
  typedef ClipRectangle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(ClipRectangle::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(ClipRectangle::VT_Y, y, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(ClipRectangle::VT_WIDTH, width, 0.0);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(ClipRectangle::VT_HEIGHT, height, 0.0);
  }
  explicit ClipRectangleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClipRectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClipRectangle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClipRectangle> CreateClipRectangle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double width = 0.0,
    double height = 0.0) {
  ClipRectangleBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct DrawImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMAGE = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12
  };
  const fb::Image *image() const {
    return GetPointer<const fb::Image *>(VT_IMAGE);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           verifier.VerifyTable(image()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           verifier.EndTable();
  }
};

struct DrawImageBuilder {
  typedef DrawImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_image(::flatbuffers::Offset<fb::Image> image) {
    fbb_.AddOffset(DrawImage::VT_IMAGE, image);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(DrawImage::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(DrawImage::VT_Y, y, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(DrawImage::VT_WIDTH, width, 0.0);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(DrawImage::VT_HEIGHT, height, 0.0);
  }
  explicit DrawImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawImage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawImage> CreateDrawImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::Image> image = 0,
    double x = 0.0,
    double y = 0.0,
    double width = 0.0,
    double height = 0.0) {
  DrawImageBuilder builder_(_fbb);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_image(image);
  return builder_.Finish();
}

struct DrawPixel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawPixelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X, 4) &&
           VerifyField<int32_t>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
};

struct DrawPixelBuilder {
  typedef DrawPixel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(DrawPixel::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(DrawPixel::VT_Y, y, 0);
  }
  explicit DrawPixelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawPixel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawPixel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawPixel> CreateDrawPixel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0) {
  DrawPixelBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct DrawString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_ALIGN = 10
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  fb::Align align() const {
    return static_cast<fb::Align>(GetField<int32_t>(VT_ALIGN, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<int32_t>(verifier, VT_ALIGN, 4) &&
           verifier.EndTable();
  }
};

struct DrawStringBuilder {
  typedef DrawString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(DrawString::VT_TEXT, text);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(DrawString::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(DrawString::VT_Y, y, 0.0);
  }
  void add_align(fb::Align align) {
    fbb_.AddElement<int32_t>(DrawString::VT_ALIGN, static_cast<int32_t>(align), 0);
  }
  explicit DrawStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawString> CreateDrawString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    double x = 0.0,
    double y = 0.0,
    fb::Align align = fb::Align_LEFT) {
  DrawStringBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_align(align);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DrawString> CreateDrawStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    double x = 0.0,
    double y = 0.0,
    fb::Align align = fb::Align_LEFT) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return fb::CreateDrawString(
      _fbb,
      text__,
      x,
      y,
      align);
}

struct DrawStringWrapped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawStringWrappedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_WIDTH = 10,
    VT_SPACING = 12,
    VT_ALIGN = 14
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  double spacing() const {
    return GetField<double>(VT_SPACING, 0.0);
  }
  fb::Align align() const {
    return static_cast<fb::Align>(GetField<int32_t>(VT_ALIGN, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_SPACING, 8) &&
           VerifyField<int32_t>(verifier, VT_ALIGN, 4) &&
           verifier.EndTable();
  }
};

struct DrawStringWrappedBuilder {
  typedef DrawStringWrapped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(DrawStringWrapped::VT_TEXT, text);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(DrawStringWrapped::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(DrawStringWrapped::VT_Y, y, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(DrawStringWrapped::VT_WIDTH, width, 0.0);
  }
  void add_spacing(double spacing) {
    fbb_.AddElement<double>(DrawStringWrapped::VT_SPACING, spacing, 0.0);
  }
  void add_align(fb::Align align) {
    fbb_.AddElement<int32_t>(DrawStringWrapped::VT_ALIGN, static_cast<int32_t>(align), 0);
  }
  explicit DrawStringWrappedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawStringWrapped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawStringWrapped>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawStringWrapped> CreateDrawStringWrapped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    double x = 0.0,
    double y = 0.0,
    double width = 0.0,
    double spacing = 0.0,
    fb::Align align = fb::Align_LEFT) {
  DrawStringWrappedBuilder builder_(_fbb);
  builder_.add_spacing(spacing);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_align(align);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DrawStringWrapped> CreateDrawStringWrappedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    double x = 0.0,
    double y = 0.0,
    double width = 0.0,
    double spacing = 0.0,
    fb::Align align = fb::Align_LEFT) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return fb::CreateDrawStringWrapped(
      _fbb,
      text__,
      x,
      y,
      width,
      spacing,
      align);
}

struct FillPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillPathBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FillPathBuilder {
  typedef FillPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FillPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FillPath> CreateFillPath(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FillPathBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FontHeight FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FontHeightBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FontHeightBuilder {
  typedef FontHeight Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FontHeightBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FontHeight> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FontHeight>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FontHeight> CreateFontHeight(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FontHeightBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MeasureString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MeasureStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct MeasureStringBuilder {
  typedef MeasureString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(MeasureString::VT_TEXT, text);
  }
  explicit MeasureStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MeasureString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MeasureString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MeasureString> CreateMeasureString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  MeasureStringBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MeasureString> CreateMeasureStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return fb::CreateMeasureString(
      _fbb,
      text__);
}

struct Pop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PopBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PopBuilder {
  typedef Pop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pop> CreatePop(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PopBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Push FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PushBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PushBuilder {
  typedef Push Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PushBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Push> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Push>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Push> CreatePush(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PushBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rotate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RotateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLE = 4
  };
  double angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ANGLE, 8) &&
           verifier.EndTable();
  }
};

struct RotateBuilder {
  typedef Rotate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_angle(double angle) {
    fbb_.AddElement<double>(Rotate::VT_ANGLE, angle, 0.0);
  }
  explicit RotateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rotate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rotate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rotate> CreateRotate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double angle = 0.0) {
  RotateBuilder builder_(_fbb);
  builder_.add_angle(angle);
  return builder_.Finish();
}

struct Scale FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScaleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct ScaleBuilder {
  typedef Scale Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Scale::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Scale::VT_Y, y, 0.0);
  }
  explicit ScaleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scale> CreateScale(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  ScaleBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SetColor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4
  };
  const fb::Color *color() const {
    return GetPointer<const fb::Color *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           verifier.EndTable();
  }
};

struct SetColorBuilder {
  typedef SetColor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_color(::flatbuffers::Offset<fb::Color> color) {
    fbb_.AddOffset(SetColor::VT_COLOR, color);
  }
  explicit SetColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetColor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetColor> CreateSetColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::Color> color = 0) {
  SetColorBuilder builder_(_fbb);
  builder_.add_color(color);
  return builder_.Finish();
}

struct SetFontFace FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetFontFaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FONT_FACE = 4
  };
  const fb::FontFace *font_face() const {
    return GetPointer<const fb::FontFace *>(VT_FONT_FACE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FONT_FACE) &&
           verifier.VerifyTable(font_face()) &&
           verifier.EndTable();
  }
};

struct SetFontFaceBuilder {
  typedef SetFontFace Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_font_face(::flatbuffers::Offset<fb::FontFace> font_face) {
    fbb_.AddOffset(SetFontFace::VT_FONT_FACE, font_face);
  }
  explicit SetFontFaceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetFontFace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetFontFace>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetFontFace> CreateSetFontFace(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::FontFace> font_face = 0) {
  SetFontFaceBuilder builder_(_fbb);
  builder_.add_font_face(font_face);
  return builder_.Finish();
}

struct TransformPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct TransformPointBuilder {
  typedef TransformPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(TransformPoint::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(TransformPoint::VT_Y, y, 0.0);
  }
  explicit TransformPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformPoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformPoint> CreateTransformPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  TransformPointBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Translate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TranslateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DX = 4,
    VT_DY = 6
  };
  double dx() const {
    return GetField<double>(VT_DX, 0.0);
  }
  double dy() const {
    return GetField<double>(VT_DY, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DX, 8) &&
           VerifyField<double>(verifier, VT_DY, 8) &&
           verifier.EndTable();
  }
};

struct TranslateBuilder {
  typedef Translate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dx(double dx) {
    fbb_.AddElement<double>(Translate::VT_DX, dx, 0.0);
  }
  void add_dy(double dy) {
    fbb_.AddElement<double>(Translate::VT_DY, dy, 0.0);
  }
  explicit TranslateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Translate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Translate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Translate> CreateTranslate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double dx = 0.0,
    double dy = 0.0) {
  TranslateBuilder builder_(_fbb);
  builder_.add_dy(dy);
  builder_.add_dx(dx);
  return builder_.Finish();
}

struct CanvasOperationList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CanvasOperationListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATIONS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::CanvasOperation>> *operations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::CanvasOperation>> *>(VT_OPERATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPERATIONS) &&
           verifier.VerifyVector(operations()) &&
           verifier.VerifyVectorOfTables(operations()) &&
           verifier.EndTable();
  }
};

struct CanvasOperationListBuilder {
  typedef CanvasOperationList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_operations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::CanvasOperation>>> operations) {
    fbb_.AddOffset(CanvasOperationList::VT_OPERATIONS, operations);
  }
  explicit CanvasOperationListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CanvasOperationList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CanvasOperationList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CanvasOperationList> CreateCanvasOperationList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::CanvasOperation>>> operations = 0) {
  CanvasOperationListBuilder builder_(_fbb);
  builder_.add_operations(operations);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CanvasOperationList> CreateCanvasOperationListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::CanvasOperation>> *operations = nullptr) {
  auto operations__ = operations ? _fbb.CreateVector<::flatbuffers::Offset<fb::CanvasOperation>>(*operations) : 0;
  return fb::CreateCanvasOperationList(
      _fbb,
      operations__);
}

}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_CANVAS_FB_H_
